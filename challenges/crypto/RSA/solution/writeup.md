# RSA Challenge Write-up

## Description

Got p, q, n, e, c. No excuses.

## Challenge Overview

This is a straightforward RSA decryption challenge where all the necessary components are provided:

- `p` and `q`: The two prime factors of `n`
- `n`: The modulus (p × q)
- `e`: The public exponent
- `c`: The encrypted message (ciphertext)

The goal is to decrypt the ciphertext to recover the original message containing the flag.

## Given Values

```python
p = 11752898189721656415758022203738178860337485859841207882239255254813156880083003451361685517755625725180776540539620511563469138074071001826696788332938749
q = 12452672719439878228749697778829318314556739351003812662776493451642917440781597440438345457262305334829767602614898688015947636457572708056834095851209913
n = 146354994661501201090371536506916591767862276963305601521508818383114091853525192182564442406200097774116264176249510795959907920157997479310270600797284279203839071457430892988671766955199730936822182267588819330747434689601943790122273603153224586364552411931862521104589464531576803096838764107362570618837
e = 65537
c = 53251061241972886277843821222876528014839792224815585816122446161552034066430518801757592154438938633412591993722342169573595048472782247571672054554779734936701206472237103411403014872379815434949454103363490522855367360723361647429864800680715939608457650803399026352116414374858006244746941261618144689182
```

## Solution Approach

Since we have both prime factors `p` and `q`, we can easily calculate the private key and decrypt the message. Here's the step-by-step process:

### Step 1: Calculate φ(n) (Euler's totient function)

For RSA, when n = p × q where p and q are prime:

```
φ(n) = (p - 1) × (q - 1)
```

### Step 2: Calculate the private key d

The private key `d` is the modular multiplicative inverse of `e` modulo φ(n):

```
d ≡ e^(-1) (mod φ(n))
```

### Step 3: Decrypt the ciphertext

Use the private key to decrypt:

```
m ≡ c^d (mod n)
```

### Step 4: Convert to readable format

Convert the decrypted integer back to bytes and then to a string.

## Solution Code

```python
from Crypto.Util.number import long_to_bytes

# Given values
p = 11752898189721656415758022203738178860337485859841207882239255254813156880083003451361685517755625625180776540539620511563469138074071001826696788332938749
q = 12452672719439878228749697778829318314556739351003812662776493451642917440781597440438345457262305334829767602614898688015947636457572708056834095851209913
n = 146354994661501201090371536506916591767862276963305601521508818383114091853525192182564442406200097774116264176249510795959907920157997479310270600797284279203839071457430892988671766955199730936822182267588819330747434689601943790122273603153224586364552411931862521104589464531576803096838764107362570618837
e = 65537
c = 53251061241972886277843821222876528014839792224815585816122446161552034066430518801757592154438938633412591993722342169573595048472782247571672054554779734936701206472237103411403014872379815434949454103363490522855367360723361647429864800680715939608457650803399026352116414374858006244746941261618144689182

# Step 1: Calculate phi(n)
phi = (p - 1) * (q - 1)

# Step 2: Calculate private key d
d = pow(e, -1, phi)

# Step 3: Decrypt the ciphertext
m = pow(c, d, n)

# Step 4: Convert to readable format
flag = long_to_bytes(m)

print("Flag:", flag.decode())
```

## Output

```
Flag: ghctf{RSA_1s_E4sy_Wh3n_Y0u_H4v3_p_q}
```
